package cn.jrc.test;

import cn.jrc.domain.Page;
import cn.jrc.domain.Result;
import cn.jrc.service.Searcher;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * @author Created By Jrc
 * @version v.0.1
 * @date 2018/5/6 10:58
 */
public class SearcherTest {
    @Test
    public void getPage(){
        Searcher searcher = new Searcher();
        searcher.setDesc(false);
        Page<Result> page = searcher.getPage("java c++", 1,4);
        assertEquals(page.getList().size(),4);
        assertEquals(page.getPageNum(),1);
        assertEquals(page.getLimit(),4);
        System.out.println(page);
    }

    @Test
    public void test(){
        String description = "of Python vs Ruby, and I all find them completely unhelpful, because they all turn around why feature X sucks in language Y, or that claim language Y doesn't have X, although in fact it does. I also know exactly why I prefer Python, but that's also subjective, and wouldn't help anybody choosing, as they might not have the same tastes in development as I do. It would therefore be interesting to list the differences, objectively. So no \"Python's lambdas sucks\". Instead explain what Ruby's lambdas can do that Python's can't. No subjectivity. Example code is good! Don't have several differences in one answer, please. And vote up the ones you know are correct, and down those you know are incorrect (or are subjective). Also, differences in syntax is not interesting. We know Python does with indentation what Ruby does with brackets and ends, and that @ is called self in Python. UPDATE: This is now a community wiki, so we can add the big differences here. Ruby has a class reference in the class body In Ruby you have a reference to the class (self) already in the class body. In Python you don't have a reference to the class until after the class construction is finished. An example: class Kaka puts self end self in this case is the class, and this code would print out \"Kaka\". There is no way to print out the class name or in other ways access the class from the class definition body in Python (outside method definitions). All classes are mutable in Ruby This lets you develop extensions to core classes. Here's an example of a rails extension: class String def starts_with?(other) head = self[0, other.length] head == other end end Python (imagine there were no ''.startswith method): def starts_with(s, prefix): return s[:len(prefix)] == prefix You could use it on any sequence (not just strings). In order to use it you should import it explicitly e.g., from some_module import starts_with. Ruby has Perl-like scripting features Ruby has first class regexps, $-variables, the awk/perl line by line input loop and other features that make it more suited to writing small shell scripts that munge text files or act as glue code for other programs. Ruby has first class continuations Thanks to the callcc statement. In Python you can create continuations by various techniques, but there is no support built in to the language. Ruby has blocks With the \"do\" statement you can create a multi-line anonymous function in Ruby, which will be passed in as an argument into the method in front of do, and called from there. In Python you would instead do this either by passing a method or with generators. Ruby: amethod { |here| many=lines+of+code goes(here) } Python (Ruby blocks correspond to different constructs in Python): with amethod() as here: # `amethod() is a context manager many=lines+of+code goes(here) Or for here in amethod(): # `amethod()` is an iterable many=lines+of+code goes(here) Or def function(here): many=lines+of+code goes(here) amethod(function) # `function` is a callback Interestingly, the convenience statement in Ruby for calling a block is called \"yield\", which in Python will create a generator. Ruby: def themethod yield 5 end themethod do |foo| puts foo end Python: def themethod(): yield 5 for foo in themethod(): print foo Although the principles are different, the result is strikingly similar. Ruby supports functional style (pipe-like) programming more easily myList.map(&:description).reject(&:empty?).join(\"\\n\") Python: descriptions = (f.description() for f in mylist) \"\\n\".join(filter(len, descriptions)) Python has built-in generators (which are used like Ruby blocks, as noted above) Python has support for generators in the language. In Ruby 1.8 you can use the generator module which uses continuations to create a generator from a block. Or, you could just use a block/proc/lambda! Moreover, in Ruby 1.9 Fibers are, and can be used as, generators, and the Enumerator class is a built-in generator 4 docs.python.org has this generator example: def reverse(data): for index in range(len(data)-1, -1, -1): yield data[index] Contrast this with the above block examples. Python has flexible name space handling In Ruby, when you import a file with require, all the things defined in that file will end up in your global namespace. This causes namespace pollution. The solution to that is Rubys modules. But if you create a namespace with a module, then you have to use that namespace to access the contained classes. In Python, the file is a module, and you can import its contained names with from themodule import *, thereby polluting the namespace if you want. But you can also import just selected names with from themodule import aname, another or you can simply import themodule and then access the names with themodule.aname. If you want more levels in your namespace you can have packages, which are directories with modules and an __init__.py file. Python has docstrings Docstrings are strings that are attached to modules, functions and methods and can be introspected at runtime. This helps for creating such things as the help command and automatic documentation. def frobnicate(bar): \"\"\"frobnicate takes a bar and frobnicates it >>> bar = Bar() >>> bar.is_frobnicated() False >>> frobnicate(bar) >>> bar.is_frobnicated() True \"\"\" Ruby's equivalent are similar to javadocs, and located above the method instead of within it. They can be retrieved at runtime from the files by using 1.9's Method#source_location example use Python has multiple inheritance Ruby does not (\"on purpose\" -- see Ruby's website, see here how it's done in Ruby). It does reuse the module concept as a type of abstract classes. Python has list/dict comprehensions Python: res = [x*x for x in range(1, 10)] Ruby: res = (0..9).map { |x| x * x } Python: >>> (x*x for x in range(10)) at 0xb7c1ccd4> >>> list(_) [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] Ruby: p = proc { |x| x * x } (0..9).map(&p) Python 2.7+: >>> {x:str(y*y) for x,y in {1:2, 3:4}.items()} {1: '4', 3";
        description = description.substring(1,Math.min(description.length(), 100));
        System.out.println(description);
    }
}
